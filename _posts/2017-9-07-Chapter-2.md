---
layout: post
title: Exam Ref 70-480 | Chapter 2
excerpt_separator: <!--more-->
---

<!--more-->
### Implement Program Flow
You need to provide users with certain website functions only under certain conditions, a concept known as *program flow*. Without program flow, JS programs would process from top to bottom in the order in which the code was written.
+ Program flow can be conditional, iterative, or behavioral:
    + *Conditional* program flow is based on evaluating state to make a decision as to which code should run.
    + *Iterative* flow is the ability to process lists or collections of information systematically and consistently.
    + *Behavioral* flow can be defined as an event or callback in which specific logic should be applied based on user engagement with the web application or the completion of another task.

Flow can - and almost always will - include a combination of all three.

Another special type of program flow involves *exception handling*. Exception handling constructs provide the ability to run specific logic in the case of an error in the program.

### Objective 2.1: Implement program flow
* **Evaluate expressions, including using *switch* statements, *if/then* statements, and operators**

Table 2-1 (page 112) Conditional and logical operators: >, <, >=, <=, !=, ==, ===, &&, ||

> EXAM TIP:
    Two conditional operators are available for checking equality: == (equality operator) and === (identity operator). Checking for equality with the == operator will ignore the underlying data type, whereas the == identity operator will consider data type. Look at the following example:
    ```
    var n = 2000, s = '2000';
    alert(n == s);
    alert(n ===s );
    ```
    The first expression, which uses the equality operator, evaluates to true because the string is cast to a number for the purpose of the evaluation. The second expression, which uses the identity operator, evaluates to false because the string '2000' isn't equal to the integer 2000.

> EXAM TIP:
    When using the logical OR operator in an *if* statement, the JS engine knows that it can proceed if any of the statements are true. As such, it evaluates the expressions from left to right until it finds one that's true. As soon as it does, it won't evaluate any further expressions but will immediately jump into the true code block. In the preceding example, if the background is green, the check for whether the background is yellow would never be evaluated.

+ Using *switch* statements: the *switch* statement provides a construct in which you can test a list of values for equality (as with the == operator).
    Example:
    ```
    switch (canvas.style.backgroundColor) {
        case 'yellow':
            alert('slow down');
            break;
        case 'green':
            alert('proceed');
            break;
        case 'red':
            alert('stop');
            break;
        default:
            alert('unkown condition');
            break;
    }
    ```
    Omitting the *break* keyword will cause unexpected behavior.
    The last piece of the *switch* statement is the optional *default* keyword, which serves as a failsafe.

> IMPORTANT: A VALID *SWITCH* STATEMENT:
    The values used in the *case* statement for the purposes of the evaluation must be expressed as a constant. For example, switching on an integer value to determine whether it's divisible by another number won't work bc the case would require an expression instead of a constant value. For example, case x/10: would be an invalid case statement. However, the switch statement itself can accept an expression to evaluate against all cases inside the switch block.

    + Ternary Operators: The syntax of the ternary operation is `<expression> ? <true part>: <false part>`
    + Working with Arrays:
        ```
        var anArray = new Array();
        var anArray = new Array(5);
        var anArray = new Array('soccer', 'basketball', ..., 'badminton');
        var anArray = ['soccer','basketball',...,'badminton'];
        ```

> EXAM TIP:
    Sizing arrays is very dynamic. In the preceding example, even though the array is initially declared to have a length of 5, if you try to access the 10th element, the array automatically resizes to accommodate the requested length. The following example demonstrates this concept:
    ```
    var anArray = new Array(5);
    alert(anArray.length);
    anArray[9] = 'soccer';
    alert(anArray.length);
    ```

> EXAM TIP:
    Some array methods affect the *Array* object directly, whereas other methods return a new *Array* object. For the exam, you must understand when each case is applicable.

> NOTE: Using *PUSH* and *POP* on any Array
    You can use the *pop* and *push* methods in any context to add and remove items from the end of an array. The stack concept is useful but isn't a confining mechanism that limits use of those methods to just stack arrays.

+ The *shift* and *unshift* methods work in the exact opposite way from the *pop* and *push* methods. The *shift* method removes and returns the first element of the array, whereas the *unshift* method inserts new elements at the beginning of the array.
+ Using pop and push or shift and unshift will result in *last-in, first-out*. However, using *push* and *shift* will result in a first-in-first-out queue.
+ The *every* method lets you process specific logic for each array element to determine whether any of them meet some condition. Example:
    ```
    var evenNumbers = new Array(0,2,4,6,8,10,12);
    var allEven = evenNumbers.every(evenNumberCheck, this);
    if (allEven) {
        ...
    } else {
    ...
    }
    function evenNumberCheck(value,index,array) {
        return (value % 2) == 0;
    }
    ```
    In this code, assume that the evenNumber array is created with a list of what you expected to be all even numbers. To validate this, you can use the *every* method.
    The *every* method takes two parameters:
        + The name of the function that should be processed for each element
        + An optional reference to the array object

    The *some* method works very much like the *every* method. The difference is that *some* checks only whether any item in the array meets the criteria. In this case, the *some* method returns *true* if the called function returns *ture* for any single element.
    The *forEach* method enables an application to process some logic against each item in the array.
    ```
    var sportsArray = ['soccer','basketball','hockey','football','cricket','rugby'];
    sportsArray.forEach(offerSport);
    function offerSport(value,index,array) {
        var sportsList = document.getElementById("sportsList");
        var bullet = document.createElement("li");
        bullet.innerText = value;
        sportsList.appendChild(bullet);
    }
    ```
    The array elements aren't sorted in this case. You can chain the methods together to ensure that the elements are, for example, alphabetized:
    `sportsArray.sort().forEach(offerSport);`

    The *filter* method provides a way to remove items for an array based on some processing done in the callback function. The *filter* method returns a new array containing the elements that are included based on a return value of *true* or *false* from the callback function.
    ```
    var evenNumbers = new Array(0,2,4,6,8,10,12);
    var allEven = evenNumbers.filter(evenNumberCheck, evenNumbers);

    // work with even numbers...

    function evenNumberCheck(value,index,array) {
        return (value % 2) == 0;
    }
    ```

    The *map* method enables you to replace values in the array.
    The following example demonstrates having every number in an array rounded off appropriately:
    ```
    var money = [12.8,15.9,21.7,35.2];
    var roundedMoney = money.map(roundOff,money);
    ...
    function roundOff(value, position, array) {
        return Math.round(value);
    }
    ```
    This example provides the square of a series of numbers:
    ```
    var numbers = [1,2,3,4,5,6,7,8];
    var squares = numbers.map(squareNumber, numbers);
    ...
    function squareNumber(value, position, array) {
        return value*value;
    }
    ```

    The *reduce* and *reduceRight* methods are recursive. Each result of the callback function is passed back into the *callback* method as previous return value along with the current element to be passed in. The *reduce* method processes the elements of the array in ascending order, whereas the *reduceRight* processes the elements of the array in descending order.
    The following example demonstartes using the *reduce* method to calculate a factorial:
    ```
    var numbers = [1,2,3,4,5,6,7,8,9,10];
    var factorials = numbers.reduce(factorial);
    function factorial(previous, current) {
        return previous * current);
    }
    ```
    In this function, the factorial for 10 is calculated.

> EXAM TIP:
    Some advanced functions enable you to change the source array, whereas others don't. This is an important aspect to keep clear.

The syntax of the *for* loop is as follows:
```
for (<counter>; <expression>;<counter increment>)
{
    <code to run>
}
```

The *for...in* loop is a method for iterating over an object's properties. Take the following example:
```
var person = { firstName: "Jane", lastName: "Doe", birthDate: "Jan 5, 1925", gender: "female" };
for (var prop in person) {
    document.write(prop);
}
```
This prints out the name of each property on the custom *person* object.
If you want the loop to print the property values instead, each property needs to be accessed via the property indexer of the object as in this example:
```
var person = { firstName: "Jane", lastName: "Doe", birthDate: "Jan 5, 1925", gender: "female" };
for (var prop in person) {
    document.write(person[prop]);
}
```

The *while* loop lets you run a code block until some condition evaluates to *false*:
```
while(<expression>){
    <code block>
}
```

The key difference b/w the *while* loop and the *do...while* loop is that *do...while* always runs at least the first time.
```
do{
    <code block>
} while(<expression>)
```

> EXAM TIP:
    The *break* keyword breaks out of only the currently running loop. If the loop containing the *break* is nested inside another loop, the outer loop continues to iterate as controlled by its own expression.

* **Thought Experiment**
    + Identifying subtleties in syntax: Various constructs perform the same function but with a different syntax. For example, the real difference b/w a *switch* statement and nested *if...else* statements is minimal. Also, the *while* and *for* loops both evaluate a condition to know whether the loop should proceed.
    1. When is a *for* loop better than a *while* loop?
    2. How is the readability of the code affected?

    Answer:
    Writing clean JS comes w/ some clear advantages. Choosing the correct construct to handle a problem is imperative to achieving the goal of clean script.
    A *for* loop and *while* loop can both get the same jobs done interchangeably, but some semantic differences make one more preferable over the other in various situations. When you know how many times a loop must run, the *for* loop is ideal. It has all the built-in semantics to handle a counter to iterate a known number of times, It can be replaced with a *while* loop, but the *while* loop requires extra variables and code added to the loop to take care of the counting of the number of times the loop runs.
    The *while* loop is better when you don't know the number of times a loop will run; it's indeterminate. This is where the loop runs until the logic within the loop achieves a certain state; hence, why the *while* loop evaluates on a Boolean expression.
    You can apply the same logic when choosing b/w an *if* statement and a *switch* statement. Although a *switch*statement can easily be replaced by an *if* statement, the inverse isn't true. Checking single values for equality in an *if...else* construct can become long and cumbersome. *if* statements allow for more complex evaluations, including compound evaluations using AND and OR logic. *switch* statements are more useful for evaluating a single value against a long list of possible values such as enumeration. Choosing the correct construct for the problem is imperative to readable and maintainable script.

* **Objective Summary**
    + The *for* and *for...in* iterate for a known length of values.
    + The *while* and *do...while* loops run until a Boolean condition is set to *false*.
    + Arrays provide a mechanism in which to create lists of things.

* **Objective Review**
    1. Which of the following keywords provide iterative control flow?
        + C: The *for* loop provides iterative flow control.
    2. Which of the following array methods combines two arrays?
        + D: The *concat* method combines the elements of two arrays into one array.
    3. Which iterative control syntax can guarantee that the loop is processed at least once?
        + C: The *do...while* loop runs a Boolean condition after it runs once.
    4. Which keyword is used to exit a loop?
        + B: The *break* keyword exits an iterative control loop.

### Objective 2.2: Raise and handle an event
* **Use events, including handling an event by using an an anonymous function and declaring and handling bubbled events**

The event object is accessed within an event handler function, using the window object as shown: `var evnt = window.event;`
The event object is a property of the window object.

> NOTE: ACCESSING THE EVENT CONTEXT: In IE, the *window* event is the method required to access the event object. However, in some browsers, the event object is passed to the event function as a param.
```
<html>
    <head>
        <script>
        window.onload = onloadHandler();

            function onloadHandler() {
                alert("hello event.");
            }
        </script>
    </head>
    <body>
        ...
    </body>
</html>
```

The *addEventListener* method accepts two required params and one optional param: `addEventListener(<event name>, <event function>, <optional cascade rule>)`

Example:
```
<script>
    window.addEventListener("load", onloadHandler, false);
    window.addEventListener("load", onloadHandler2, false);
    window.addEventListener("load", onloadHandler3, false);

    function onloadHandler() {
        alert("hello event 1.");
    }
    function onloadHandler2() {
        alert("hello event 2.");
    }
    function onloadHandler() {
        alert("hello event 3.");
    }
</script>
```
To remover the *onloadHandler2* event, all that's needed is a call to the *removeEventListener*: `window.removeEventListener("load", onloadHandler2, false);`

Anonymous functions cannot be removed if added into a listener. To add an anonymous function to an event listener:
```
window.addEventListener("load", function() {
    document.getElementById("outer").addEventListener("click", outerDivClick,false); },
false);
```

Canceling an event: This tells the runtime to stop any further processing of the event.
```
window.onload = function () {
    var a = document.getElementById("aLink");
    a.onclick = OverrideAnchorClick;
}
function OverrideAnchorClick() {
    //do custom logic for the anchor
    window.event.returnValue = false;
    //or
    //return false;
```
In this case, when the anchor is clicked, the customer event handler runs but no further logic is processed. Hence, the nav typically provided by the `<a>` element is prevented from running.

Event bubbling is the concept that applies when the HTML document has nested elements.
```
document.getElementById("outer").addEventListener("click", outerDivClick, false);
document.getElementById("middle").addEventListener("click", middleDivClick, false);
document.getElementById("inner").addEventListener("click", innerDivClick, false);
```
This will result in:
```
1. inner Div Clicked
2. middle Div Clicked
3. outer Div Clicked
```

```
document.getElementById("outer").addEventListener("click", outerDivClick, ture);
document.getElementById("middle").addEventListener("click", middleDivClick, true);
document.getElementById("inner").addEventListener("click", innerDivClick, false);
```
This will result in:
```
1. outer Div Clicked
2. middle Div Clicked
3. inner Div Clicked
```
The order of the event processing has reversed to be cascading instead of bubbling.
If *cancelBubble* is set to true, the event bubbling or cascading stops with the event listener that sets it.
```
function innerDivClick() {
    appendText("inner Div Clicked");
    window.event.cancelBubble = true;
}
```
Now, when the inner *div* is clicked, the output is as follow:
`1. inner Div Clicked`
The bubbling of the event up to the middle *div* and outer *div* has been prevented.

A change event occurs when the value associated with an element changes. This most commonly occurs in input elements such as text-based inputs and others such as the range element. An example of the change event in action is shown here:
```
<script>
    window.onload = function() {
        document.getElementById("aRange").addEventListener("change", rangeChangeEvent);
    {

    function rangeChangeEvent() {
        document.getElementById("rangeValue").innerText = this.valuel
    }
</script>
...
<body>
    <input id="aRange" type="range" max="200" min="0" value="0"/>
    <div id="rangeValue"></div>
</body>
```
In this example, as the range slider control changes with the mouse dragging it from one side to the other, the div displays the value of the slider bar.

> EXAM TIP:
    This example uses the *this* keyword. In this context, the *this* keyword provides a direct element that created the element. In this way, *this* provides shortcut access to the element rather than gets a reference via one of the document search methods.

Focus events occur when an element receives or loses the focus.

Table 2-2 (page 140) The DOM focus events: focus, blue, focusin, focusout

The following code shows how to use the *blur* event:
```
<script>
    window.onload = function() {
        document.getElementById("firstNameText").focus();
        document.getElementById("firstNameText").addEventListener("blur", function () {
            if (this.value.length < 5) {
                document.getElementById("ruleViolation").innerText =
                    'First Name is required to be 5 letters.';
                document.getElementById("ruleViolation").style.color = 'red';
                this.focus();
            }
        });
    }
</script>
```

Keyboard events occur when keys are pressed on the keyboard.

Table 2-3 (page 140) Available keyboard events: keydown, keyup, keypress

The following example listens for the *keydown* event on the text box and shows the *keycode* for the pressed key:
```
document.getElementById("firstNameText").addEventListener("keydown", function () {
    document.getElementById("outputText").innerText = window.event.keyCode;
});
```
Code such as this can be used to filter out invalid characters from being entered into a text box. With keyboard events, extra properties are available on the event object to help out. For example, you might need to know whether the Shift key or Control key was also being pressed.

Table 2-4 (page 141) Event object properties for keyboard events: altKey, keyCode, ctrlKey, shiftKey

> EXAM TIP:
    In some cases, depending on the key, only the *keydown* event fires. The arrow keys are such an example: *keydown* fires but not *keyup* or *keypress*

You can use properties such as *ctrlKey* with the *keyCode* event to give the users something similar to hotkey functionality to automatically navigate the focus to specific fields:
```
document.onkeydown = function () {
    if(window.event.ctrlKey && String.fromCharCode(window.event.keyCode) == 'F')
        document.getElementById("firstNameText").focus();
    if(window.event.ctrlKey && String.fromCharCode(window.event.keyCode) == 'L')
        document.getElementById("lastNameText").focus();
    return false;
}
```

The DOM provides extensive exposure to mouse activity through the mouse events.

Table 2-5 (page 141-142) Available mouse events: click, dblclick, mousedown, mouseup, mouseenter or mouseover, mouseleave, mousemove

The mouse events provide additional information on the event object.

Table 2-6 (page 142) Properties of the mouse event: clientX, clientY, offsetX, offsetY, screenX, screenY

The following code demonstrates capturing each coordinate set:
```
window.onload = function () {
    document.getElementById("yellowBox").addEventListener("click",yellowBoxClick);
}
function yellowBoxClick() {
    document.write("Client X: " + window.event.clientX + " ClientY: " + window.event.clientY);
    document.write("<BR />");
    document.write("offsetX: " + window.event.offsetX + " offsetY: " + window.event.offsetY);
    document.write("<BR />");
    document.write("screen X: " + window.event.screenX + " screenY: " + window.event.screenY);
}
```
This code assumes a *div* called *yellowBox* that raises its click event when the mouse clicks it. You can easily change the event to *mousedown* or *mouseup* to achieve the same outcome.
The *mouseenter* and *mouseleave* events indicate when the mouse cursor position has entered or left the area covered by a particular element, respectively.
The following code demonstrates applying a transformation to the *div* element on the *mouseenter* and removing it on the *mouseleave*:
```
<style>
    .scale {
        transform:scale(1.5);
    }
</style>
<script>
    window.onload = function () {
        document.getElementById("yellowBox").addEventListener("mouseenter", yellowBoxEnter);
        document.getElementById("yellowBox").addEventListener("mouseleave", yellowBoxLeave);
    }
    function yellowBoxEnter() {
        this.classList.add("scale");
    }
    function yellowBoxLeave() {
        this.classList.remove("scale");
    }
</script>
<body>
    <div id="yellowBox" style="width: 50%; height:50%; margin: 0 auto; background-color: yellow;"></div>
</body>
```
When the mouse moves over the yellow-filled *div* the *div* scales up. When the mouse is moved off the *div*, it returns to the original size.

Drag-and-drop functionality enables users to pick up an element with the mouse and place it in another location.

Table 2-7 (page 143) Events available to drag and drop: drag, dragend, dragenter, dragleave, dragover, dragstart, drop

```
<head>
    <style>
        .dropped {
            width: 50%;
            height: 50%;
            position: relative;
            top: 25%;
            left: 25%;
            background-color: black;
        }
        .over {
            transform: scale(1.1);
        }
        .bucket {
            width: 100px;
            height: 100px;
            margin: 10px 10px 10px 10px;
            position: absolute;
        }
        .chip {
            width: 20px;
            height: 20px;
            position: absolute;
        }
        div:first-of-type {
            background-color: red;
        }
        div:nth-of-type(2) {
            background-color: green;
        }
        div:nth-of-type(3) {
            background-color: blue;
            left: 50%;
        }
        #chip {
            background-color: black;
            width: 50px;
            height: 50px;
        }
        .begin {
            position: absolute;
            left: 150px;
            top: 150px;
        }
    </style>
</head>
<body>
    <div id="bucket1" class="bucket"></div>
    <div id="bucket2" class="bucket"></div>
    <div id="bucket3" class="bucket"></div>
    <div id="chip" draggable="true" class="chip"></div>
</body>
```

For the chip to be able to be dragged, it must be draggable.
To begin the drag event, the *dragstart* must be handled:
```
var chip = document.getElementById("chip");
chip.addEventListener("dragstart", function (){
    window.event.dataTransfer.setData("Text", this.id);
});
```
In this handler, the *dataTransfer* object *setData* method is used to store what exactly is being transferred.
Next, the desired target element's event listeners must be set up. The following code shows this:
```
var b1 = document.getElementbyId("bucket1");
b1.addEventListener("dragenter", function () {
    b1.classList.add("over");
    window.event.returnValue = false;
});
b1.addEventListener("dragleave", function () {
    b1.classList.remove("over");
});
b1.addEventListener("dragover", function () {
    window.event.returnValue = false;
});
b1.addEventListener("drop", function () {
    window.event.returnValue = false;
    var data = event.dataTransfer.getData("Text");
    var d = document.getElementById(data);
    d.classList.remove("begin");
    d.classList.add("dropped");
    this.appendChild(d);
});
```
In this code, the *dragenter* event listener is established so that the user gets a visual cue with a transform that the element can be dropped onto. In the same token, the *dragleave* event listener is set up to remove the effect. The *dragover* event is set to be ignored by canceling it. This is only because *div* elements can't be dragged and dropped by default.
The last piece is the *drop* event handler. With this event handler, the drop is received. The *dataTransfer* object's *getData* method is called to retrieve what's being dropped. The ID of the source element gets a reference to the element and places it inside the target. The same code can be repeated for the other two buckets, and then chip can be dragged into each bucket.

> NOTE: DRAG-AND-DROP SUPPORT:
    For elements that don't support drag-and-drop functionality by default, the default event mechanism must be canceled. This is why *event.returnValue* is set to false.

To create a custom event, you use the *CustomEvent* object. To use custom events, you first need to create one by using the *window.CustomEvent* object:
```
myEvent = new CustomEvent("anAction",
    {
        detail: { description: "a description of the event", timeofevent: new Date(), eventcode: 2},
        bubbles: true,
        cancelable: true
    }
);
```
The *CustomEvent* object constructor accepts two params:
    + The first param is the name of the event. This is anything that makes sense for what the event is supposed to represent.
    + The second param is a dynamic object that contains a detail property that can have properties assigned to it containing information that should be passed to the event handler. Also, the param provides the ability to specify if the event should bubble and whether the event can be canceled.
The next step is to assign the event to an element on the page by using the *addEventListener* method: `document.addEventListener("anAction", customEventHandler);`
Finally, the event is raised by using the *dispatchEvent* methods: `document.dispatchEvent(myEvent);`
A function called *customEventHandler* must exist for all this to work:
```
function customEventHandler() {
    alert(window.event.detail.description);
}
```

> EXAM TIP:
    As of this writing, IE doesn't support this functionality. Custom events work correctly in other browsers, though. Be aware of how custom events work for the exam, however, bc they ar epart of the official skills being measured.

* **Thought Experiment**
    + Creating an event-full webpage: Consider an application where fields become auto-populated based on user input in other fields. Auto-population is seen sometimes on forms that require users to fill in their address. When the postal code is entered, the city, country/region, and so on are populated based on that information. How would you apply the proper event to a form that contains text boxes, check boxes, option buttons, slider bars, and so on, so that as the form is filled in, other fields are populated automatically? Perhaps when a field is filled automatically, its value triggers other fields to be populated. How can you implement the solution, considering the timing of when events are triggered.

    Answer:
    This interesting scenario can lead to a complex chain of event handling in which one event triggers other events. This requires deciding on the flow of the events through the page. Good practice is to do this on paper or workflow software to design the workflow of the events. This will require knowing when to cancel the event chain or allow it to continue processing further down the controls.

* **Objective summary**
    + Events provide a way to interact with users when they perform actions on the webpage.
    + Events cascade or bubble through the entire DOM hierarchy.
    + Focus events occur when an object gets or loses focus.
    + Keyboard events occur when keyboard keys are pressed on a focused object.
    + Mouse events occur when the mouse clicks an object or the pointer is moved over or off an object.
    + Drag-and-drop functionality provides a way to move elements from one container to another.

* **Objective review**
    1. Which of the following isn't a supported way to add an event handler to a DOM element?
        + B: Setting the attribute in CSS to a valid JS function. CSS doesn't provide a way to assign events handlers.
    2. Which of the following isn't an attribute of an anonymous function?
        + D: anonymous functions can't be assigned to a DOM element declaratively.
    3. Which code line would successfully cancel an event?
        + A: *window.event.returnValue* = false; cancels the event
    4. Which event occurs when a DOM element receives the cursor?
        + A: *focus*. The *focus* event fires when an element receives the focus.
    5. Which option provides the correct sequence of events in a drag-and-drop operation?
        + B: *dragstart, drag, dragenter, dragstop*

### Objective 2.3: Implement exception handling
Structured error handling in JS is achieved with the *try...catch...finally* construct.
The *try...catch...finally* construct handles exceptions that occur during program processing.

```
try {
    window.dosomeunsupportedmethod();
} catch (e) {
    alert("Browser does not support the desired functionality.");
}
```
By using the *try...catch* block, you can handle the error condition gracefully.

Table 2-8 (page 150) Properties available on the *exception* object: message, number, name

> NOTE: USING DEBUGGING TOOLS:
    A call to console.log was added to the *catch* block. This is a great way to add information that can be viewed in the client debugger. For ex, in IE, you can access the debugger tools by pressing F12.

Exceptions bubble up the call stack, a special stack in the processing environment that represents the functions currently being processed in sequential order.

* **Thought Experiment**
    + Micromanaging exceptions: The reason behind exception handling is, obviously, to handle exceptions. In some cases, error conditions can be predicted and if the situation occurs, it's handled and resolved. In this case, you might not want to simply wrap an entire code block into a big *try...catch* block and have the application fail to proceed.
    How would you incorporate the use of *try...catch* blocks into a longer JS routine with multiple points of potential error? Some errors can be corrected, and some might not be. The correctable errors should allow the script to continue successfully.

    Answer:
    Implementing a *try...catch* block in every function at the top of the call stack is an important way to catch unforeseen scenarios that result in the application getting into a bad state. However, this error handling routine might include situations from which you want to be able to recover. Nesting *try...catch* blocks allow this to happen. You can implement as many *try...catch* blocks as you want. Nesting them allows you to catch a specific scenario within the outer block, handle it, correct data and/or assumptions, and allow the script to continue running.

* **Objective Summary**
    + Structured error handling is provided by the JS lang in the form of the *try...catch...finally* block
    + The *try...catch...finally* block provides a way to try some logic, catch an error and handle it appropriately, and finally do some clean up
    + The *finally* block always runs whether or not an exception is thrown
    + Checking for a null value before accessing any objects to ensure that they are initialized is good practice.

* **Objective review**
    1. Which statement correctly describes the proper error handling using *try...catch...finally* blocks?
        + A: By using structured error handling, you can provide feedback to users and handle unknown situations properly.
    2. Which of the following isn't a property of the exception object?
        + B: *description* isn't a valid property.
    3. Why is checking for null a good practice?
        + A: Checking for null prevents the use of an object before it initializes and prevents unexpected results.

### Objective 2.4: Implement a callback
Callbacks are a design pattern to implement when you are working w/ multiple threads or just needing to have something work asynchronously.
The general pattern is shown here:
```
<script>
    window.onload = function () {
        WillCallBackWhenDone(MyCallBack, 3, 3);
    }
    function WillCallBackWhenDone(f, a, b) {
        var r = a * b;
        f(r);
    }
    function MyCallBack(result) {
        alert(result);
    }
</script>
```
In this code example, two functions are declared: *WillCallBackWhenDone* and *MyCallBack*. One param to the *WillCallBackWhenDone* func is a func followed by two other vars, which is in this case are numbers that will be multiplied.

> NOTE: ACCEPTING SOCKET CONNECTIONS:
    The full implementation of WebSocket API requires that a webserver have a proper server-side implementation that can accept socket connections. Technologies such as Node.js work well for this purpose. Implementation of such technologies is beyond the scope of this book, and these coee samples assume such an implementation exists.

The *WebSocket* constructor accepts two params:
    + The URL of the server-side socket to connect to, which is always prefixed with *ws* or *wss* for secure *WebSocket* connections
    + An optional list of subprotocols.

Table 2-9 (table 161) Possible values of the WebSocket *readyState*: OPEN, CONNECTING, CLOSING, CLOSED

```
$.ajax({
    url: searchPath,
    cache: false,
    dataType: "xml",
    success: function (data) {
        $(data).find("fruit").each(
                function () {
                    $('#searchResults').append($(this).text());
                    $('#searchResults').append("<BR />");
                }
        )
    }
});
```
The first param being set is the *url* that the AJAX call will be requesting. For security reasons, to prevent cross-site scripting, this URL must be within the same domain as the webpage itself.
The next param, *cache*, is optional and indicates whether the call can use a cached copy. The third param, *datatype*, indicates the expected data type, which could be XML or JSON, for example.
The last param set in this example is the *success* property. This param takes a func that results of the AJAX calls should be passed into for the webpage to do some work with.
Another property that can be set on the AJAX call, as good practice, is the *error* property so that any error conditions can be handled gracefully.
```
error: function (xhr, textStatus, errorThrown) {
    $('#searchResults').append(errorThrown);
}
```
The error func is passed three useful params:
    + The HTTP request itsself
    + The HTTP error number (such as 404)
    + THe error text (such as Not Found)

The jQuery AJAX toolkit supports not only getting data, but also posting data to the server. The default request type is GET. To change a call to a post, you change the value of the property to POST: `type: "POST"`

One of the most common issues encountered by web developers is cross-browser compatibility, jQuery is one of the toolkits available to help bridge the issue.
Example of jQuery syntax to wire up an event:
```
$('#searchButton').click(function () {
...
}
```

Better example:
```
$("document").ready(function () {
    $("#GameRow td").click(function () {
        alert($(this).text());
    });
});
...
<table>
    <tr id="GameRow">
        <td id="door1">Door 1</td>
        <td id="door2">Door 2</td>
        <td id="door3">Door 3</td>
    </tr>
</table>
<table>
    <tr id="SomeOtherRow">
        <td id="cell1">Not a Door 1</td>
        <td id="cell2">Not a Door 2</td>
        <td id="cell3">Not a Door 3</td>
    </tr>
</table>
```
The click events are assigned only to the `<td>` elements that are children of an element named *GameRow*.

The *error* and *success* properties allow you to specify a function that the AJAX framework calls after it either successfully completes the request or encounters an error.
Callback funcs can also be used in the form of a parameter to another func. Consider the following example that accepts a user's input to evaluate if a score is a pass or a fail:
```
$("document").ready( function() {
    $("#Button1").click( function() {
        DoLongTask($(#inputValue").val(),
            function (result,data) {
                if (result == "SUCCESS")
                    alert(data + " is a Success");
                else
                    alert(data + " is a fail");
            });
    });
});
function DoLongTask(n,f)
{
    if(n<10)
        f("SUCCESS", n);
    else
        f("FAIL", n);
}
```
This code makes heavy use of anonymous funcs and callbacks.

The *this* pointer is a special object provided by the jQuery framework.
```
$("document").ready(
    function () {
        $('#floorDiv').click(function () {
            $(this).css("background-color", "red");
        })
    }
);
```

* **Thought Experiment**
    + Creating a chat application: Would you use WebSockets or would you use AJAX to create an asynchronous bidirectional communication application in JS? For this thought experiment, describe how you would create an HTML5 JS based real-time chat app.

    Answer:
    The concept of real-time chat or real-time communications isn't new. However, HTML5 WebSockets make the concept easier than ever to implement in HTML5 webpages. Implementing this type of application is beyond the scope of the book but it is very useful in understanding the power that WebSockets provide. Search 'WebSocket JavaScript chat application' for more examples.
    AJAX provides asynchronous communication but doesn't provide a bidirectional functionality that ccan deliver real-time communications.

* **Objective summary**
    + WebSockets provide bidirectional communication w/ a server.
    + WebSockets support both non-secure(ws) and secure(wss) connection to the server.
    + The jQuery AJAX framework provides a mechanism to make asynchronous web requests
    + You can wire up events by using the jQuery selector syntax.

* **Objective review**
    1. Which of the following is a valid WebSocket instantiation?
        + C: *wsConnection = new WebSocket('wss://studygroup.70480.com',['soap','xmpp']);*
    2. Which of the following statements properly handles the reception of data from a WebSocket?
        + C: *wsConnection.onmessage = function(msg){...};* receives the resulting data.
    3. Which list identifies the properties that need to be set up to make an AJAX call?
        + C: *url, datatype, success*; *cache* isn't required.
    4. Why is wiring up evenets with jQuery easier?
        + A: Wiring up events with jQuery allows you to assign the event listener to many elements at once by using the selector syntax.

### Objective 2.5: Create a web worker process
Web workers present a way of developing multithreaded JS apps.

The *Worker* object is available from the global namespace and is created like so: `var webWorker = new Worker("workercode.js");`

Table 2-10 (page 176) *Worker* object operations: postMessage, terminate, onmessage, onerror

As soon as the *Worker* object is instantiated, it's available for use at any time. All that's needed to start the process is to call the *postMessage* method: `webWorker.postMessage("");`
As soon as the *webWorker* is running, the main app continues as usual. If something occurs that the worker process should be canceled, a call to the termiante method would achieve this: `webWorker.terminate();`
After the worker process completes and results need to be processed, the *onmessage* function is called from the worker. This should be set up before starting the worker: `webWorker.onmessage = function(evt) {...}`
Next, you need to create the worker code itself. You create the workercode.js file that was used in the constructor. The first line of the file will be: `onmessage = function(e){...}`
This tells the runtime the entry point to the work to be run within the worker process. Somewhere in the worker process, where a result should be sent back to the calling app, the *postMessage* method is called:
```
onmessage = function(e) {
    ... self.postMessage(result);
}
```
The *self* keyword is similar to the *this* keyword.

The *postMessage* method accepts a param that enables it to pass data to the worker that it might need to operate on or with. The *postMessage* param is a string - it can take any serializable obj such as native data types, JSON objects, or XML. The param can't be a func.
An input box can be added to the HTML and the entered value ccan be passed to the worker. This would look like this:
```
var value = document.getElementById("inputValue").value;
worker.postMessage(value);
```
Then in the worker, the value would be accessed like this:
```
onmessage = function (evt) {
    var work = evt.data;
    ...
}
```
The function receives an event obj with a property called *data* that contains whatever was passed into the worker.

If you want a high volume of workers, consider creating a pool that can be used in a round-robin fashion so that not too many workers are created.
The DOM shouldn't be manipulated from a worker process. The worker context has no access to the window object, document obj, or any parent obj.

Following the same patternsas for a worker from the main webpage, a worker can create workers as well. All constructs must be followed for passing data and getting data returned.

You can set up a web worker to run on a specified interval in the background. This is done by using any existing *setTimeout* or *setInterval* methods. The *setTimeout* method calls a specified function after the specified delay. The *setInterval* calls the specified function repeatedly after each specified time interval.
For example, the following code runs the worker after 3 secs:
```
var work = new Worker("workerFile.js");
setTimeout(function() { work.postMessage(""); },3000);
```

However, the following code runs the worker every 3 secs:
```
var work = new Worker("workerFile.js");
setInterval(function() {work.postMessage("");}, 3000);
```

* **Thought Experiment**
    + Creating a page that performs a fireworks show: As an exercise to create a webpage using timeouts and intervals, think about how you would create a page that would perform a fireworks show. Different types of fireworks need to fire at diff intervals and delays. They each need to travel to a diff height, and diff types of fireworks have diff explosion effects and colors.
    1. Would a larger firework show be too intensive? Why or why not?
    2. Would web workers help make it more fluid? Why or why not?

    Answer:
    For an app such as this, you must consider the amount of work required to get it done. The larger the show, the more intense the app will be. You could use *setInterval* and *setTimeout* to control the show's flow. However, the actual delivery of the firework display and explosion would be suited nicely for a web worker. This allows the user interface thread to continue to work uninterrupted while the complex logic of animating the fireworks occurs on a worker.

* **Objective summary*
    + Web workers allow the JS runtime to provide multithreading.
    + Web workers can have sub-workers.
    + The number of workers that you cn use is limitless, but too many workers can hinder performance.
    + Web workers can receive a single param containing any data needed for the worker.
    + Web workers don't have access to the DOM of the calling page.
    + Use *setTimeout* to delay before running a script func. Use *setInterval* to repeat a script func after every specified interval.

* **Objective review**
    1. Which of the following isn't a valid web worker operation?
        + C: *close* isn't a method on the web worker
    2. Which method cancels a web worker?
        + B: *terminate* cancels a web worker
    3. Where must you place the JS code to run in the context of a web worker?
        + C: In its own JS file; The code must be in its own JS file, and the name of the file is passed to the web worker as a param.
    4. How many web workers/subworkers can run concurrently?
        + C: A limitless number of workers; There is not limit on the number of workers that can be created. However, too many will result in performance issues.
    5. To have a script run continually every 30 secs, which line of code should be used?
        + D: *setInterval(function() {worker.postMessage("");}, 30000);* calles the passed-in func every interval as specified by the second param in milliseconds.